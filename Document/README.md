# 알고리즘 문서

- [자료구조](#자료구조)
- [알고리즘](#알고리즘)
- [코딩테스트](#코딩테스트)

> 💡 Tip
>
> - 처음부터 어려운 걸 하려고 하지 말고, 간단한 것부터 시작하자.
> - 선택한 언어의 문법과 클래스를 잘 파악하자.
> - 풀고 난 후 다른 사람의 풀이 참고하자.
> - 경험이 쌓이면 익숙해진다. 조급해하지 말자.

# 자료구조

- 배열(Array)
- 스택(Stack)
- 큐(Queue)
- 우선순위 큐(Priority Queue)
- 연결리스트(Linked List)
- 힙(Heap)
- 해시 테이블(Hash Table)
- 트리(Tree)
- 그래프(Graph)
- BST

> 💡 자료구조 공부 방향
>
> - **Order** 자료 구조 안에 있는 데이터들의 순서가 보장되는지
> - **Unique** 중복된 데이터가 들어갈 수 있는지
> - **Search** 검색할 때 얼마나 효율적인지
> - **Modification** 수정할 때 얼마나 효율적인지
> - 시간이 없다면 구현방법, 사항을 일일이 공부하는 것 보다는, 해당 자료구조는 어떤 상황에 쓰는 것이 좋고 어떤 API 들이 있는지 위주로 공부하면 좋음.

## 추가

- list 구조: 배열, 동적 배열, 링크드 리스트(linked list)
- set, map 구조: 해시맵, 이진 검색 트리, 힙

위 자료구조는 필수 메소드가 어떻게 구현되어 있는지, 런타임은 어떻게 동작하는지 알아야 합니다. (list의 필수 메소드는 set, get, pushAtEnd, popAtEnd, insertByIndex, removeByIndex, set의 필수 메소드는 insert, remove, contains? 입니다.)

예를 들면 getNearestElementTo(x) 메소드를 구현할 수 있어야 합니다. 이 메소드 즉, x와 가장 가까운 값을 찾는 구현을 하려면 이진 검색트리를 알아야 합니다.

이 문제를 해결하는데 이런 내용을 알아야 합니다.

- 이진 검색트리 구현에 균형을 맞추는 코드가 필요하다는 점을 알아야 하지만 세부 내용은 몰라도 괜찮습니다. (선택 자료: 자기 균형 BST을 어떻게 구현하는지 빠르게 배우고 싶다면 이 트립을 참조하세요. 어떻게 레드블랙 트리가 동작하는지 이해하고 싶다면 좌편향 레드블랙 트리 또는 2-3-4 트리를 배우세요.)
- 큐를 스택 두 개로 구현할 수 있다는 점을 알아야 합니다.

# 알고리즘

알고리즘이란, 어떠한 문제를 해결하기 위한 일련의 절차를 정해놓은 로직(주어진 인풋으로 정의된 계산을 수행한 뒤 아웃풋을 내는, 계산 과정을 의미) 제한된 공간과 시간 안에서 정확하고 효율적으로 결과값을 얻기 위해 알고리즘이 필요하다.

## 알고리즘 종류

- 정렬(Sorting) ⭐
  - 버블 정렬(Bubble Sort)
  - 선택 정렬(Selection Sort)
  - 삽입 정렬(Insertion Sort)
  - 퀵 정렬(Quick Sort)
  - 병합 정렬(Merge Sort)
  - 힙 정렬(Heap Sort)
  - 기수 정렬(Radix Sort)
  - 계수 정렬(Count Sort)
    > - Runtime of a sort
    > - Time space complexity
- 백트래킹 ⭐
- 분할정복
- 최단거리
- 동적 계획법(Dynamic Programming) ⭐
- 탐욕적 기법(Greedy Algorithm)
- 유클리드 호제법(최대공약수, 최소공배수)
- DFS(Depth First Search, 깊이 우선 탐색), BFS(Breadth First Search, 너비 우선 탐색) ⭐
- 이분 탐색(Binary Search) ⭐
- 해시 테이블(Using Hash Tables) ⭐
- Brute Force ⭐
- 그래프(위상정렬, 다익스트라) ⭐
- 투포인터(슬라이딩 윈도우) ⭐
- 조합, 순열 ⭐
- 파라메트릭 서치 ⭐

- Matching Parenthesis problem ⭐
- Variables / Pointers manipulation ⭐
- reverse linked list(duplicates, removing duplicates) ⭐
- Recursion ⭐
- Custom data structures(Object oriented programming) ⭐
- 최장 증가 수열(LIS)
- 최소 공통 조상(LCA)
- 비트 마스크(BitMask)

## 기타 공부하면 좋을 주제들

- 비트 연산
- 진수 변환

---

## 알고리즘 학습법

<https://baactree.tistory.com/52>와 <https://blog.yena.io/studynote/2018/11/14/Algorithm-Basic.html>에서 상당 부분을 인용해 정리한 문서입니다.

### 1. 기본 개념 이해

[알고리즘에 필요한 기본 개념 참고](#알고리즘에-필요한-기본-개념)

- 방법
  - 책
  - 온라인 사이트
    - [LibreWiki](https://librewiki.net/wiki/%EC%8B%9C%EB%A6%AC%EC%A6%88:%EC%88%98%ED%95%99%EC%9D%B8%EB%93%AF_%EA%B3%BC%ED%95%99%EC%95%84%EB%8B%8C_%EA%B3%B5%ED%95%99%EA%B0%99%EC%9D%80_%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%BC%ED%95%99/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EA%B8%B0%EC%B4%88) 알고리즘 내용을 한 페이지에 보기 좋게 정리한 사이트
    - [visualgo](https://visualgo.net/ko) 정렬, 트리 등의 원리를 이해하기 쉽게 시각화하여 보여주는 사이트(알고리즘 진행 과정을 보여줌)
    - [geeksforgeeks](https://www.geeksforgeeks.org/) 알고리즘 예시 (영어로 되어있음)
  - 인터넷 강의
  - 앱
    - 알고리즘 도감(입문자에게 추천)
    - geeksforgeeks

### 2. 기본 알고리즘 코드 학습

기초적인 원리를 이해했다면, 코드로 어떻게 풀어 나가는지 예제 알고리즘(정형화된 풀이 공식)을 공부한다.

> ex) 자료구조 중 배열에 대해 학습했다면, `List`와 `Array`가 어떻게 다른지, 코드로 어떻게 작성하고 어떤 클래스와 함수를 쓸 수 있는지 파악한다. 여기서 헷갈린다면 언어에 대한 문법을 다시 복습할 필요가 있다.

코드를 작성하는 것에 대해서는 [geeksforgeeks](https://www.geeksforgeeks.org/)에 상세하게 잘 나와있다.

IDE의 자동완성이나 Import에 익숙해지지 않게 코드를 작성하는 것도 좋은 방법!

### 3. 쉬운 문제 풀기

언어, 난이도, 주제(검색, 정렬, 그리디 등)에 따라 문제를 검색하여 풀이

- 코딩 테스트 문제 풀이 사이트
  - 국내
    - 백준(BOJ)
    - 프로그래머스
  - 해외
    - 릿코드(leetcode)
    - 코딜리티(codility)

### 알고리즘에 필요한 기본 개념

- **시간 복잡도**

  문제를 해결하는 데 걸리는 시간과 입력된 자료 양의 관계를 일컫는다. 시간 복잡도를 나타낼 때는 Big O 표기법을 이용한다.

  | 시간 복잡도       | 설명                                                  |
  | ----------------- | ----------------------------------------------------- |
  | O(1)              | 상수 형태. n의 값에 상관없이 일정한 양의 계산만 한다. |
  | O(logn)           | 로그 형태                                             |
  | O(n)              | 선형                                                  |
  | O(nlogn)          | 선형로그 형태                                         |
  | O(n2), O(n3), ... | 다차 형태                                             |
  | O(2n)             | 지수 형태                                             |
  | O(n!)             | 팩토리얼 형태                                         |

  위에서 아래로 갈수록 시간 복잡도가 높고 느려진다. 시간 복잡도를 고려해 알고리즘을 작성해야 한다.

  > 예제
  >
  > 1부터 n까지의 합을 구하는 다음 예제를 보자. 방법 1은 `for`를 이용해 n번의 연산을 하기 때문에 `O(n)`의 시간 복잡도를 가진다. 반면 방법 2는 n의 크기와 상관없이 1번 연산하기 때문에 `O(1)`의 시간 복잡도를 가진다.
  >
  > ```java
  > // 방법 1
  > int n, res = 0;
  > for(int i= 1; i <=n; i++){
  >     res += 1;
  > }
  > System.out.println(res);
  > ```
  >
  > ```java
  > // 방법 2
  > int n, res = 0;
  > res = n*(n+1)/2;
  > System.out.println(res);
  > ```

- **자료구조**

  데이터를 메모리에 효율적으로 배치, 저장, 관리하는 방법을 의미한다. 컴퓨터에서 프로그램을 실행하면 CPU에서 메모리로 데이터를 이동해서 처리하는데, 이때 메모리를 효율적으로 사용하기 위해서는 데이터 특성에 맞는 자료구조를 사용하는 것이 중요하다.

  ![image](https://user-images.githubusercontent.com/33214449/104835914-32efc580-58ed-11eb-987b-04767dae80c8.png)
  출처: [초보몽키](https://wayhome25.github.io/cs/2017/04/17/cs-18/)의 개발공부로그

- **정렬**

  [Tony님의 블로그, 정렬 정리](https://medium.com/@fiv3star/%EC%A0%95%EB%A0%AC%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-sorting-algorithm-%EC%A0%95%EB%A6%AC-8ca307269dc7)

### PS(Problem Solving)을 잘하기 위한 3요소

- 구현력
- 문제해결능력
- 배경지식

**1. 구현력**

> 생각한 알고리즘을 소스코드로 구현하는 능력(프로그램 순서도, 사용할 변수나 함수를 정의하는 과정)

- 구현력이 부족할 때 드는 생각

  - _대충 어떻게 하라는지는 알겠는데 코딩하려니 한 줄도 못 짜겠다._
  - _내가 지금 뭘 짜고 있는지 모르겠다._
  - _코드가 1000바이트가 넘어가면 엄두가 안난다._
  - _디버깅을 못 하겠다._

- 구현력을 향상시키기 위해서는
  - 어떤 프로그램을 만들고자 하는지 명확히 하기
    입력-과정-출력을 순서도로 적어보고 구체적으로 어떤 데이터 타입, 자료구조를 사용할지 종이에 차근차근 적어가며 연습하는 것이 좋다. 이 연습을 자주 하다보면 이를 곧 머리속으로 생각하게 될 것

**2. 문제해결능력**

> 알고있는 알고리즘, 자료구조, 테크닉들을 문제에 맞게 변형하여 적용하는 능력. 문제를 창의적인 시각에서 접근하는 해결 능력을 의미한다. 중위권->상위권으로 갈 때 발목을 잡는 것이 바로 문제해결능력이므로 향상시키기 위해선 많은 노력이 필요하다.

- 문제해결능력이 부족할 때 드는 생각

  - _어떻게 접근해야 할 지 모르겠다._
  - _그래서 솔루션을 열었는데 내가 아는 알고리즘, 자료구조인 상황_

- 문제해결능력을 향상시키기 위해서는
  - 양질의 문제(30분~2시간 고민하면 해결 가능한 문제 수준)를 풀기
  - 이전에 본인이 접근한 다양한 방법들을 잘 정리해두는 것

**3. 배경지식**

> 기초적인 프로그래밍 문법 및 알고리즘, 자료구조 등을 아는 것. 선형대수학과 확률 등과 같이 기본적인 수학적 지식을 아는 것과 같은 능력이다. 공부해서 익히기 가장 쉬운 능력이다.

- 배경지식이 부족할 때 드는 생각

  - _어떻게 접근할지 몰라서 솔루션을 봤는데 생판 모르는 외계어가 적혀져 있다._

- 배경지식을 향상시키기 위해서는
  - 책, 온라인 사이트들의 문서 등을 통해 공부

> 만약 배경지식을 충분히 공부했음에도 불구하고 문제를 접근조차 하지 못하겠다면 본인은 [컴퓨팅적 사고력] 이 부족한 상황이다. 문제해결능력의 하위호환인데 이 능력이 부족하면 [ 재귀함수, 완전탐색, 백트래킹, BFS, 분할정복 ] 에 대한 이해 자체가 어렵다. 이해하지를 못해서 문제에 적용할 수 도 없는것이다. [컴퓨터가 1초에 1억번의 연산을 할 수 있음]을 이해하고 [따라서 어떤 시간 복잡도 까지는 가능] 함을 이해하고, [메모리 제한이 몇 이므로 배열을 어느정도 까지는 할당 할 수 있겠다] 라는 생각을 할 수 있어야 하고, 재귀함수를 트리형태로 [어떻게 진입하고 무엇을 하고 무엇을 리턴하고 종료되는지]를 그릴 수 있어야한다. 완전탐색에 있어서 [상태공간의 정의]를 할 수 있어야 하고 [현재 상태에서 다음 상태로 갈 수 있는 방법이 몇가지 인지]를 이해하고 [최종 종료 상태와 최초 진입 상태] 가 무엇인지 이해하고 그림으로 표현할 수 있어야 한다.

## 추가

다음 알고리즘들은 어떻게 구현하는지 알아야 한다.

- 그래프 알고리즘: 너비 우선 탐색(breadth first search), 깊이 우선 탐색(depth first search), 다익스트라 알고리즘 (dikstra’s algorithm)
- 빠른 정렬 알고리즘 하나. 병합 정렬(mergesort) 또는 퀵 정렬(quicksort)
- 배열에서 수행하는 이진 검색. 이 알고리즘은 제대로 작성하기 매우 까다롭고 대략적으로 알고리즘을 이해하고 있더라도 코드로 작성해볼 가치가 있습니다.

# 코딩 테스트

- 코딩 테스트의 목적
  - 얼마나 정확하고 효율적으로 코드를 작성했는지 +
  - 자료구조, 알고리즘에 대한 이해도, 시간 복잡도에 대한 이해도
    > - ex) 이 알고리즘을 이용하여 문제를 풀이한 이유는? 그 방법이 다른 방법에 비해 가지는 장단점은?
    > - ex) `Map` 자료구조를 사용했다면, `Set`을 사용하지 않고 `Map`을 사용한 이유는? 그 둘의 차이점은 무엇인가?

# References

- 알고리즘 학습법에 대한 조언 https://edykim.com/ko/post/advice-on-learning-algorithms/
- 알고리즘 공부 시작 방법 및 순서 https://blog.yena.io/studynote/2018/11/14/Algorithm-Basic.html
- 알고리즘 공부, 어떻게 해야하나요? https://baactree.tistory.com/52
- 드림코딩 엘리 자료구조, 알고리즘, 코딩 테스트 관련 영상 https://www.youtube.com/watch?v=okHGRlgR8ps&feature=youtu.be
